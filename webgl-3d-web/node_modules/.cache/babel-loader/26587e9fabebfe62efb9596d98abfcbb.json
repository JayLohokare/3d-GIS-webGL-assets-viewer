{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar OBJECT_RE = /^[og]\\s*(.+)?/;\nvar MATERIAL_RE = /^mtllib /;\nvar MATERIAL_USE_RE = /^usemtl /;\n\nvar MeshMaterial = function () {\n  function MeshMaterial(_ref) {\n    var index = _ref.index,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? '' : _ref$name,\n        mtllib = _ref.mtllib,\n        smooth = _ref.smooth,\n        groupStart = _ref.groupStart;\n\n    _classCallCheck(this, MeshMaterial);\n\n    this.index = index;\n    this.name = name;\n    this.mtllib = mtllib;\n    this.smooth = smooth;\n    this.groupStart = groupStart;\n    this.groupEnd = -1;\n    this.groupCount = -1;\n    this.inherited = false;\n  }\n\n  _createClass(MeshMaterial, [{\n    key: \"clone\",\n    value: function clone() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.index;\n      return new MeshMaterial({\n        index: index,\n        name: this.name,\n        mtllib: this.mtllib,\n        smooth: this.smooth,\n        groupStart: 0\n      });\n    }\n  }]);\n\n  return MeshMaterial;\n}();\n\nvar MeshObject = function () {\n  function MeshObject() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    _classCallCheck(this, MeshObject);\n\n    this.name = name;\n    this.geometry = {\n      vertices: [],\n      normals: [],\n      colors: [],\n      uvs: []\n    };\n    this.materials = [];\n    this.smooth = true;\n    this.fromDeclaration = null;\n  }\n\n  _createClass(MeshObject, [{\n    key: \"startMaterial\",\n    value: function startMaterial(name, libraries) {\n      var previous = this._finalize(false);\n\n      if (previous && (previous.inherited || previous.groupCount <= 0)) {\n        this.materials.splice(previous.index, 1);\n      }\n\n      var material = new MeshMaterial({\n        index: this.materials.length,\n        name: name,\n        mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n        smooth: previous !== undefined ? previous.smooth : this.smooth,\n        groupStart: previous !== undefined ? previous.groupEnd : 0\n      });\n      this.materials.push(material);\n      return material;\n    }\n  }, {\n    key: \"currentMaterial\",\n    value: function currentMaterial() {\n      if (this.materials.length > 0) {\n        return this.materials[this.materials.length - 1];\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"_finalize\",\n    value: function _finalize(end) {\n      var lastMultiMaterial = this.currentMaterial();\n\n      if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n        lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n        lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n        lastMultiMaterial.inherited = false;\n      }\n\n      if (end && this.materials.length > 1) {\n        for (var mi = this.materials.length - 1; mi >= 0; mi--) {\n          if (this.materials[mi].groupCount <= 0) {\n            this.materials.splice(mi, 1);\n          }\n        }\n      }\n\n      if (end && this.materials.length === 0) {\n        this.materials.push({\n          name: '',\n          smooth: this.smooth\n        });\n      }\n\n      return lastMultiMaterial;\n    }\n  }]);\n\n  return MeshObject;\n}();\n\nvar ParserState = function () {\n  function ParserState() {\n    _classCallCheck(this, ParserState);\n\n    this.objects = [];\n    this.object = null;\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.materialLibraries = [];\n    this.startObject('', false);\n  }\n\n  _createClass(ParserState, [{\n    key: \"startObject\",\n    value: function startObject(name) {\n      var fromDeclaration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (this.object && !this.object.fromDeclaration) {\n        this.object.name = name;\n        this.object.fromDeclaration = fromDeclaration;\n        return;\n      }\n\n      var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true);\n      }\n\n      this.object = new MeshObject(name);\n      this.object.fromDeclaration = fromDeclaration;\n\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n        var declared = previousMaterial.clone(0);\n        declared.inherited = true;\n        this.object.materials.push(declared);\n      }\n\n      this.objects.push(this.object);\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true);\n      }\n    }\n  }, {\n    key: \"parseVertexIndex\",\n    value: function parseVertexIndex(value, len) {\n      var index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    }\n  }, {\n    key: \"parseNormalIndex\",\n    value: function parseNormalIndex(value, len) {\n      var index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    }\n  }, {\n    key: \"parseUVIndex\",\n    value: function parseUVIndex(value, len) {\n      var index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 2) * 2;\n    }\n  }, {\n    key: \"addVertex\",\n    value: function addVertex(a, b, c) {\n      var src = this.vertices;\n      var dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    }\n  }, {\n    key: \"addVertexPoint\",\n    value: function addVertexPoint(a) {\n      var src = this.vertices;\n      var dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    }\n  }, {\n    key: \"addVertexLine\",\n    value: function addVertexLine(a) {\n      var src = this.vertices;\n      var dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    }\n  }, {\n    key: \"addNormal\",\n    value: function addNormal(a, b, c) {\n      var src = this.normals;\n      var dst = this.object.geometry.normals;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    }\n  }, {\n    key: \"addColor\",\n    value: function addColor(a, b, c) {\n      var src = this.colors;\n      var dst = this.object.geometry.colors;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    }\n  }, {\n    key: \"addUV\",\n    value: function addUV(a, b, c) {\n      var src = this.uvs;\n      var dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n      dst.push(src[b + 0], src[b + 1]);\n      dst.push(src[c + 0], src[c + 1]);\n    }\n  }, {\n    key: \"addUVLine\",\n    value: function addUVLine(a) {\n      var src = this.uvs;\n      var dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n    }\n  }, {\n    key: \"addFace\",\n    value: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {\n      var vLen = this.vertices.length;\n      var ia = this.parseVertexIndex(a, vLen);\n      var ib = this.parseVertexIndex(b, vLen);\n      var ic = this.parseVertexIndex(c, vLen);\n      this.addVertex(ia, ib, ic);\n\n      if (ua !== undefined && ua !== '') {\n        var uvLen = this.uvs.length;\n        ia = this.parseUVIndex(ua, uvLen);\n        ib = this.parseUVIndex(ub, uvLen);\n        ic = this.parseUVIndex(uc, uvLen);\n        this.addUV(ia, ib, ic);\n      }\n\n      if (na !== undefined && na !== '') {\n        var nLen = this.normals.length;\n        ia = this.parseNormalIndex(na, nLen);\n        ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n        ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n        this.addNormal(ia, ib, ic);\n      }\n\n      if (this.colors.length > 0) {\n        this.addColor(ia, ib, ic);\n      }\n    }\n  }, {\n    key: \"addPointGeometry\",\n    value: function addPointGeometry(vertices) {\n      this.object.geometry.type = 'Points';\n      var vLen = this.vertices.length;\n\n      var _iterator = _createForOfIteratorHelper(vertices),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var vertex = _step.value;\n          this.addVertexPoint(this.parseVertexIndex(vertex, vLen));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"addLineGeometry\",\n    value: function addLineGeometry(vertices, uvs) {\n      this.object.geometry.type = 'Line';\n      var vLen = this.vertices.length;\n      var uvLen = this.uvs.length;\n\n      var _iterator2 = _createForOfIteratorHelper(vertices),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var vertex = _step2.value;\n          this.addVertexLine(this.parseVertexIndex(vertex, vLen));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(uvs),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var uv = _step3.value;\n          this.addUVLine(this.parseUVIndex(uv, uvLen));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }]);\n\n  return ParserState;\n}();\n\nexport default (function (text) {\n  var state = new ParserState();\n\n  if (text.indexOf('\\r\\n') !== -1) {\n    text = text.replace(/\\r\\n/g, '\\n');\n  }\n\n  if (text.indexOf('\\\\\\n') !== -1) {\n    text = text.replace(/\\\\\\n/g, '');\n  }\n\n  var lines = text.split('\\n');\n  var line = '';\n  var lineFirstChar = '';\n  var lineLength = 0;\n  var result = [];\n  var trimLeft = typeof ''.trimLeft === 'function';\n\n  for (var i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    line = trimLeft ? line.trimLeft() : line.trim();\n    lineLength = line.length;\n    if (lineLength === 0) continue;\n    lineFirstChar = line.charAt(0);\n    if (lineFirstChar === '#') continue;\n\n    if (lineFirstChar === 'v') {\n      var data = line.split(/\\s+/);\n\n      switch (data[0]) {\n        case 'v':\n          state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\n          if (data.length === 8) {\n            state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n          }\n\n          break;\n\n        case 'vn':\n          state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n          break;\n\n        case 'vt':\n          state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n          break;\n\n        default:\n      }\n    } else if (lineFirstChar === 'f') {\n      var lineData = line.substr(1).trim();\n      var vertexData = lineData.split(/\\s+/);\n      var faceVertices = [];\n\n      for (var j = 0, jl = vertexData.length; j < jl; j++) {\n        var vertex = vertexData[j];\n\n        if (vertex.length > 0) {\n          var vertexParts = vertex.split('/');\n          faceVertices.push(vertexParts);\n        }\n      }\n\n      var v1 = faceVertices[0];\n\n      for (var _j = 1, _jl = faceVertices.length - 1; _j < _jl; _j++) {\n        var v2 = faceVertices[_j];\n        var v3 = faceVertices[_j + 1];\n        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n      }\n    } else if (lineFirstChar === 'l') {\n      var lineParts = line.substring(1).trim().split(' ');\n      var lineVertices = void 0;\n      var lineUVs = [];\n\n      if (line.indexOf('/') === -1) {\n        lineVertices = lineParts;\n      } else {\n        lineVertices = [];\n\n        for (var li = 0, llen = lineParts.length; li < llen; li++) {\n          var parts = lineParts[li].split('/');\n          if (parts[0] !== '') lineVertices.push(parts[0]);\n          if (parts[1] !== '') lineUVs.push(parts[1]);\n        }\n      }\n\n      state.addLineGeometry(lineVertices, lineUVs);\n    } else if (lineFirstChar === 'p') {\n      var _lineData = line.substr(1).trim();\n\n      var pointData = _lineData.split(' ');\n\n      state.addPointGeometry(pointData);\n    } else if ((result = OBJECT_RE.exec(line)) !== null) {\n      var name = (' ' + result[0].substr(1).trim()).substr(1);\n      state.startObject(name);\n    } else if (MATERIAL_USE_RE.test(line)) {\n      state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n    } else if (MATERIAL_RE.test(line)) {\n      state.materialLibraries.push(line.substring(7).trim());\n    } else if (lineFirstChar === 's') {\n      result = line.split(' ');\n\n      if (result.length > 1) {\n        var value = result[1].trim().toLowerCase();\n        state.object.smooth = value !== '0' && value !== 'off';\n      } else {\n        state.object.smooth = true;\n      }\n\n      var material = state.object.currentMaterial();\n      if (material) material.smooth = state.object.smooth;\n    } else {\n      if (line === '\\0') continue;\n      throw new Error(\"Unexpected line: \\\"\".concat(line, \"\\\"\"));\n    }\n  }\n\n  state.finalize();\n  var meshes = [];\n  var materials = [];\n\n  var _iterator4 = _createForOfIteratorHelper(state.objects),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var object = _step4.value;\n      var geometry = object.geometry;\n      if (geometry.vertices.length === 0) continue;\n      var mesh = {\n        header: {\n          vertexCount: geometry.vertices.length / 3\n        },\n        attributes: {}\n      };\n\n      switch (geometry.type) {\n        case 'Points':\n          mesh.mode = 0;\n          break;\n\n        case 'Line':\n          mesh.mode = 1;\n          break;\n\n        default:\n          mesh.mode = 4;\n          break;\n      }\n\n      mesh.attributes.POSITION = {\n        value: new Float32Array(geometry.vertices),\n        size: 3\n      };\n\n      if (geometry.normals.length > 0) {\n        mesh.attributes.NORMAL = {\n          value: new Float32Array(geometry.normals),\n          size: 3\n        };\n      }\n\n      if (geometry.colors.length > 0) {\n        mesh.attributes.COLOR_0 = {\n          value: new Float32Array(geometry.colors),\n          size: 3\n        };\n      }\n\n      if (geometry.uvs.length > 0) {\n        mesh.attributes.TEXCOORD_0 = {\n          value: new Float32Array(geometry.uvs),\n          size: 2\n        };\n      }\n\n      mesh.materials = [];\n\n      var _iterator5 = _createForOfIteratorHelper(object.materials),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var sourceMaterial = _step5.value;\n          var _material = {\n            name: sourceMaterial.name,\n            flatShading: !sourceMaterial.smooth\n          };\n          mesh.materials.push(_material);\n          materials.push(_material);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      mesh.name = object.name;\n      meshes.push(mesh);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return {\n    meshes: meshes,\n    materials: materials\n  };\n});","map":{"version":3,"sources":["../../../src/lib/parse-obj.js"],"names":["OBJECT_RE","MATERIAL_RE","MATERIAL_USE_RE","MeshMaterial","index","name","mtllib","smooth","groupStart","MeshObject","vertices","normals","colors","uvs","libraries","previous","material","Array","end","lastMultiMaterial","mi","ParserState","fromDeclaration","previousMaterial","declared","value","len","parseInt","a","b","c","src","dst","ua","ub","uc","na","nb","nc","vLen","ia","ib","ic","uvLen","nLen","vertex","uv","state","text","lines","line","lineFirstChar","lineLength","result","trimLeft","i","l","data","parseFloat","lineData","vertexData","faceVertices","j","jl","vertexParts","v1","v2","v3","lineParts","lineVertices","lineUVs","li","llen","parts","pointData","meshes","materials","object","geometry","mesh","header","vertexCount","attributes","size","sourceMaterial","_material","flatShading"],"mappings":"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","sourcesContent":["// OBJ Loader, adapted from THREE.js (MIT license)\n//\n// Attributions per original THREE.js source file:\n//\n// @author mrdoob / http://mrdoob.com/\n\n// o object_name | g group_name\nconst OBJECT_RE = /^[og]\\s*(.+)?/;\n// mtllib file_reference\nconst MATERIAL_RE = /^mtllib /;\n// usemtl material_name\nconst MATERIAL_USE_RE = /^usemtl /;\n\nclass MeshMaterial {\n  constructor({index, name = '', mtllib, smooth, groupStart}) {\n    this.index = index;\n    this.name = name;\n    this.mtllib = mtllib;\n    this.smooth = smooth;\n    this.groupStart = groupStart;\n    this.groupEnd = -1;\n    this.groupCount = -1;\n    this.inherited = false;\n  }\n\n  clone(index = this.index) {\n    return new MeshMaterial({\n      index,\n      name: this.name,\n      mtllib: this.mtllib,\n      smooth: this.smooth,\n      groupStart: 0\n    });\n  }\n}\n\nclass MeshObject {\n  constructor(name = '') {\n    this.name = name;\n\n    this.geometry = {\n      vertices: [],\n      normals: [],\n      colors: [],\n      uvs: []\n    };\n\n    this.materials = [];\n    this.smooth = true;\n\n    this.fromDeclaration = null;\n  }\n\n  startMaterial(name, libraries) {\n    const previous = this._finalize(false);\n\n    // New usemtl declaration overwrites an inherited material, except if faces were declared\n    // after the material, then it must be preserved for proper MultiMaterial continuation.\n    if (previous && (previous.inherited || previous.groupCount <= 0)) {\n      this.materials.splice(previous.index, 1);\n    }\n\n    const material = new MeshMaterial({\n      index: this.materials.length,\n      name,\n      mtllib:\n        Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n      smooth: previous !== undefined ? previous.smooth : this.smooth,\n      groupStart: previous !== undefined ? previous.groupEnd : 0\n    });\n\n    this.materials.push(material);\n\n    return material;\n  }\n\n  currentMaterial() {\n    if (this.materials.length > 0) {\n      return this.materials[this.materials.length - 1];\n    }\n\n    return undefined;\n  }\n\n  _finalize(end) {\n    const lastMultiMaterial = this.currentMaterial();\n    if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n      lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n      lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n      lastMultiMaterial.inherited = false;\n    }\n\n    // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n    if (end && this.materials.length > 1) {\n      for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n        if (this.materials[mi].groupCount <= 0) {\n          this.materials.splice(mi, 1);\n        }\n      }\n    }\n\n    // Guarantee at least one empty material, this makes the creation later more straight forward.\n    if (end && this.materials.length === 0) {\n      this.materials.push({\n        name: '',\n        smooth: this.smooth\n      });\n    }\n\n    return lastMultiMaterial;\n  }\n}\n\nclass ParserState {\n  constructor() {\n    this.objects = [];\n    this.object = null;\n\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n\n    this.materialLibraries = [];\n\n    this.startObject('', false);\n  }\n\n  startObject(name, fromDeclaration = true) {\n    // If the current object (initial from reset) is not from a g/o declaration in the parsed\n    // file. We need to use it for the first parsed g/o to keep things in sync.\n    if (this.object && !this.object.fromDeclaration) {\n      this.object.name = name;\n      this.object.fromDeclaration = fromDeclaration;\n      return;\n    }\n\n    const previousMaterial =\n      this.object && typeof this.object.currentMaterial === 'function'\n        ? this.object.currentMaterial()\n        : undefined;\n\n    if (this.object && typeof this.object._finalize === 'function') {\n      this.object._finalize(true);\n    }\n\n    this.object = new MeshObject(name);\n    this.object.fromDeclaration = fromDeclaration;\n\n    // Inherit previous objects material.\n    // Spec tells us that a declared material must be set to all objects until a new material is declared.\n    // If a usemtl declaration is encountered while this new object is being parsed, it will\n    // overwrite the inherited material. Exception being that there was already face declarations\n    // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n    if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n      const declared = previousMaterial.clone(0);\n      declared.inherited = true;\n      this.object.materials.push(declared);\n    }\n\n    this.objects.push(this.object);\n  }\n\n  finalize() {\n    if (this.object && typeof this.object._finalize === 'function') {\n      this.object._finalize(true);\n    }\n  }\n\n  parseVertexIndex(value, len) {\n    const index = parseInt(value, 10);\n    return (index >= 0 ? index - 1 : index + len / 3) * 3;\n  }\n\n  parseNormalIndex(value, len) {\n    const index = parseInt(value, 10);\n    return (index >= 0 ? index - 1 : index + len / 3) * 3;\n  }\n\n  parseUVIndex(value, len) {\n    const index = parseInt(value, 10);\n    return (index >= 0 ? index - 1 : index + len / 2) * 2;\n  }\n\n  addVertex(a, b, c) {\n    const src = this.vertices;\n    const dst = this.object.geometry.vertices;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    dst.push(src[b + 0], src[b + 1], src[b + 2]);\n    dst.push(src[c + 0], src[c + 1], src[c + 2]);\n  }\n\n  addVertexPoint(a) {\n    const src = this.vertices;\n    const dst = this.object.geometry.vertices;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n  }\n\n  addVertexLine(a) {\n    const src = this.vertices;\n    const dst = this.object.geometry.vertices;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n  }\n\n  addNormal(a, b, c) {\n    const src = this.normals;\n    const dst = this.object.geometry.normals;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    dst.push(src[b + 0], src[b + 1], src[b + 2]);\n    dst.push(src[c + 0], src[c + 1], src[c + 2]);\n  }\n\n  addColor(a, b, c) {\n    const src = this.colors;\n    const dst = this.object.geometry.colors;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    dst.push(src[b + 0], src[b + 1], src[b + 2]);\n    dst.push(src[c + 0], src[c + 1], src[c + 2]);\n  }\n\n  addUV(a, b, c) {\n    const src = this.uvs;\n    const dst = this.object.geometry.uvs;\n\n    dst.push(src[a + 0], src[a + 1]);\n    dst.push(src[b + 0], src[b + 1]);\n    dst.push(src[c + 0], src[c + 1]);\n  }\n\n  addUVLine(a) {\n    const src = this.uvs;\n    const dst = this.object.geometry.uvs;\n\n    dst.push(src[a + 0], src[a + 1]);\n  }\n\n  // eslint-disable-next-line max-params\n  addFace(a, b, c, ua, ub, uc, na, nb, nc) {\n    const vLen = this.vertices.length;\n\n    let ia = this.parseVertexIndex(a, vLen);\n    let ib = this.parseVertexIndex(b, vLen);\n    let ic = this.parseVertexIndex(c, vLen);\n\n    this.addVertex(ia, ib, ic);\n\n    if (ua !== undefined && ua !== '') {\n      const uvLen = this.uvs.length;\n      ia = this.parseUVIndex(ua, uvLen);\n      ib = this.parseUVIndex(ub, uvLen);\n      ic = this.parseUVIndex(uc, uvLen);\n      this.addUV(ia, ib, ic);\n    }\n\n    if (na !== undefined && na !== '') {\n      // Normals are many times the same. If so, skip function call and parseInt.\n      const nLen = this.normals.length;\n      ia = this.parseNormalIndex(na, nLen);\n\n      ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n      ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n      this.addNormal(ia, ib, ic);\n    }\n\n    if (this.colors.length > 0) {\n      this.addColor(ia, ib, ic);\n    }\n  }\n\n  addPointGeometry(vertices) {\n    this.object.geometry.type = 'Points';\n\n    const vLen = this.vertices.length;\n\n    for (const vertex of vertices) {\n      this.addVertexPoint(this.parseVertexIndex(vertex, vLen));\n    }\n  }\n\n  addLineGeometry(vertices, uvs) {\n    this.object.geometry.type = 'Line';\n\n    const vLen = this.vertices.length;\n    const uvLen = this.uvs.length;\n\n    for (const vertex of vertices) {\n      this.addVertexLine(this.parseVertexIndex(vertex, vLen));\n    }\n\n    for (const uv of uvs) {\n      this.addUVLine(this.parseUVIndex(uv, uvLen));\n    }\n  }\n}\n\n// eslint-disable-next-line max-statements, complexity\nexport default text => {\n  const state = new ParserState();\n\n  if (text.indexOf('\\r\\n') !== -1) {\n    // This is faster than String.split with regex that splits on both\n    text = text.replace(/\\r\\n/g, '\\n');\n  }\n\n  if (text.indexOf('\\\\\\n') !== -1) {\n    // join lines separated by a line continuation character (\\)\n    text = text.replace(/\\\\\\n/g, '');\n  }\n\n  const lines = text.split('\\n');\n  let line = '';\n  let lineFirstChar = '';\n  let lineLength = 0;\n  let result = [];\n\n  // Faster to just trim left side of the line. Use if available.\n  const trimLeft = typeof ''.trimLeft === 'function';\n\n  /* eslint-disable no-continue, max-depth */\n  for (let i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    line = trimLeft ? line.trimLeft() : line.trim();\n    lineLength = line.length;\n\n    if (lineLength === 0) continue;\n\n    lineFirstChar = line.charAt(0);\n\n    // @todo invoke passed in handler if any\n    if (lineFirstChar === '#') continue;\n\n    if (lineFirstChar === 'v') {\n      const data = line.split(/\\s+/);\n\n      switch (data[0]) {\n        case 'v':\n          state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n          if (data.length === 8) {\n            state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n          }\n          break;\n        case 'vn':\n          state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n          break;\n        case 'vt':\n          state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n          break;\n        default:\n      }\n    } else if (lineFirstChar === 'f') {\n      const lineData = line.substr(1).trim();\n      const vertexData = lineData.split(/\\s+/);\n      const faceVertices = [];\n\n      // Parse the face vertex data into an easy to work with format\n\n      for (let j = 0, jl = vertexData.length; j < jl; j++) {\n        const vertex = vertexData[j];\n\n        if (vertex.length > 0) {\n          const vertexParts = vertex.split('/');\n          faceVertices.push(vertexParts);\n        }\n      }\n\n      // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n      const v1 = faceVertices[0];\n\n      for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n        const v2 = faceVertices[j];\n        const v3 = faceVertices[j + 1];\n\n        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n      }\n    } else if (lineFirstChar === 'l') {\n      const lineParts = line\n        .substring(1)\n        .trim()\n        .split(' ');\n      let lineVertices;\n      const lineUVs = [];\n\n      if (line.indexOf('/') === -1) {\n        lineVertices = lineParts;\n      } else {\n        lineVertices = [];\n        for (let li = 0, llen = lineParts.length; li < llen; li++) {\n          const parts = lineParts[li].split('/');\n\n          if (parts[0] !== '') lineVertices.push(parts[0]);\n          if (parts[1] !== '') lineUVs.push(parts[1]);\n        }\n      }\n      state.addLineGeometry(lineVertices, lineUVs);\n    } else if (lineFirstChar === 'p') {\n      const lineData = line.substr(1).trim();\n      const pointData = lineData.split(' ');\n\n      state.addPointGeometry(pointData);\n    } else if ((result = OBJECT_RE.exec(line)) !== null) {\n      // o object_name\n      // or\n      // g group_name\n\n      // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n      // var name = result[ 0 ].substr( 1 ).trim();\n      const name = (' ' + result[0].substr(1).trim()).substr(1); // eslint-disable-line\n\n      state.startObject(name);\n    } else if (MATERIAL_USE_RE.test(line)) {\n      // material\n\n      state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n    } else if (MATERIAL_RE.test(line)) {\n      // mtl file\n\n      state.materialLibraries.push(line.substring(7).trim());\n    } else if (lineFirstChar === 's') {\n      result = line.split(' ');\n\n      // smooth shading\n\n      // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n      // but does not define a usemtl for each face set.\n      // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n      // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n      // where explicit usemtl defines geometry groups.\n      // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n      /*\n       * http://paulbourke.net/dataformats/obj/\n       * or\n       * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n       *\n       * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n       * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n       * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n       * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n       * than 0.\"\n       */\n      if (result.length > 1) {\n        const value = result[1].trim().toLowerCase();\n        state.object.smooth = value !== '0' && value !== 'off';\n      } else {\n        // ZBrush can produce \"s\" lines #11707\n        state.object.smooth = true;\n      }\n      const material = state.object.currentMaterial();\n      if (material) material.smooth = state.object.smooth;\n    } else {\n      // Handle null terminated files without exception\n      if (line === '\\0') continue;\n\n      throw new Error(`Unexpected line: \"${line}\"`);\n    }\n  }\n\n  state.finalize();\n\n  const meshes = [];\n  const materials = [];\n\n  for (const object of state.objects) {\n    const {geometry} = object;\n\n    // Skip o/g line declarations that did not follow with any faces\n    if (geometry.vertices.length === 0) continue;\n\n    const mesh = {\n      header: {\n        vertexCount: geometry.vertices.length / 3\n      },\n      attributes: {}\n    };\n\n    switch (geometry.type) {\n      case 'Points':\n        mesh.mode = 0; // GL.POINTS\n        break;\n      case 'Line':\n        mesh.mode = 1; // GL.LINES\n        break;\n      default:\n        mesh.mode = 4; // GL.TRIANGLES\n        break;\n    }\n\n    mesh.attributes.POSITION = {value: new Float32Array(geometry.vertices), size: 3};\n\n    if (geometry.normals.length > 0) {\n      mesh.attributes.NORMAL = {value: new Float32Array(geometry.normals), size: 3};\n    }\n\n    if (geometry.colors.length > 0) {\n      mesh.attributes.COLOR_0 = {value: new Float32Array(geometry.colors), size: 3};\n    }\n\n    if (geometry.uvs.length > 0) {\n      mesh.attributes.TEXCOORD_0 = {value: new Float32Array(geometry.uvs), size: 2};\n    }\n\n    // Create materials\n    mesh.materials = [];\n    for (const sourceMaterial of object.materials) {\n      // TODO - support full spec\n      const _material = {\n        name: sourceMaterial.name,\n        flatShading: !sourceMaterial.smooth\n      };\n      mesh.materials.push(_material);\n      materials.push(_material);\n    }\n\n    mesh.name = object.name;\n    meshes.push(mesh);\n  }\n\n  return {meshes, materials};\n};\n"]},"metadata":{},"sourceType":"module"}