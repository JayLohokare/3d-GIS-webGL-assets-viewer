!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var s=e();for(var r in s)("object"==typeof exports?exports:t)[r]=s[r]}}(window,(function(){return function(t){var e={};function s(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,s),o.l=!0,o.exports}return s.m=t,s.c=e,s.d=function(t,e,r){s.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},s.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)s.d(r,o,function(e){return t[e]}.bind(null,o));return r},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=0)}([function(t,e,s){(function(e){const r=s(2),o="undefined"==typeof window?e:window;o.loaders=o.loaders||{},t.exports=Object.assign(o.loaders,r)}).call(this,s(1))},function(t,e){var s;s=function(){return this}();try{s=s||new Function("return this")()}catch(t){"object"==typeof window&&(s=window)}t.exports=s},function(t,e,s){"use strict";function r(t){if(!t||!t.POSITION)return null;let e=1/0,s=1/0,r=1/0,o=-1/0,n=-1/0,i=-1/0;const a=t.POSITION.value,l=a&&a.length;if(!l)return null;for(let t=0;t<l;t+=3){const l=a[t],c=a[t+1],h=a[t+2];e=l<e?l:e,s=c<s?c:s,r=h<r?h:r,o=l>o?l:o,n=c>n?c:n,i=h>i?h:i}return[[e,s,r],[o,n,i]]}s.r(e),s.d(e,"OBJLoader",(function(){return d})),s.d(e,"OBJWorkerLoader",(function(){return u}));const o=/^[og]\s*(.+)?/,n=/^mtllib /,i=/^usemtl /;class a{constructor({index:t,name:e="",mtllib:s,smooth:r,groupStart:o}){this.index=t,this.name=e,this.mtllib=s,this.smooth=r,this.groupStart=o,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}clone(t=this.index){return new a({index:t,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0})}}class l{constructor(t=""){this.name=t,this.geometry={vertices:[],normals:[],colors:[],uvs:[]},this.materials=[],this.smooth=!0,this.fromDeclaration=null}startMaterial(t,e){const s=this._finalize(!1);s&&(s.inherited||s.groupCount<=0)&&this.materials.splice(s.index,1);const r=new a({index:this.materials.length,name:t,mtllib:Array.isArray(e)&&e.length>0?e[e.length-1]:"",smooth:void 0!==s?s.smooth:this.smooth,groupStart:void 0!==s?s.groupEnd:0});return this.materials.push(r),r}currentMaterial(){if(this.materials.length>0)return this.materials[this.materials.length-1]}_finalize(t){const e=this.currentMaterial();if(e&&-1===e.groupEnd&&(e.groupEnd=this.geometry.vertices.length/3,e.groupCount=e.groupEnd-e.groupStart,e.inherited=!1),t&&this.materials.length>1)for(let t=this.materials.length-1;t>=0;t--)this.materials[t].groupCount<=0&&this.materials.splice(t,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),e}}class c{constructor(){this.objects=[],this.object=null,this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[],this.startObject("",!1)}startObject(t,e=!0){if(this.object&&!this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=e);const s=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object=new l(t),this.object.fromDeclaration=e,s&&s.name&&"function"==typeof s.clone){const t=s.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)}finalize(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)}parseVertexIndex(t,e){const s=parseInt(t,10);return 3*(s>=0?s-1:s+e/3)}parseNormalIndex(t,e){const s=parseInt(t,10);return 3*(s>=0?s-1:s+e/3)}parseUVIndex(t,e){const s=parseInt(t,10);return 2*(s>=0?s-1:s+e/2)}addVertex(t,e,s){const r=this.vertices,o=this.object.geometry.vertices;o.push(r[t+0],r[t+1],r[t+2]),o.push(r[e+0],r[e+1],r[e+2]),o.push(r[s+0],r[s+1],r[s+2])}addVertexPoint(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])}addVertexLine(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])}addNormal(t,e,s){const r=this.normals,o=this.object.geometry.normals;o.push(r[t+0],r[t+1],r[t+2]),o.push(r[e+0],r[e+1],r[e+2]),o.push(r[s+0],r[s+1],r[s+2])}addColor(t,e,s){const r=this.colors,o=this.object.geometry.colors;o.push(r[t+0],r[t+1],r[t+2]),o.push(r[e+0],r[e+1],r[e+2]),o.push(r[s+0],r[s+1],r[s+2])}addUV(t,e,s){const r=this.uvs,o=this.object.geometry.uvs;o.push(r[t+0],r[t+1]),o.push(r[e+0],r[e+1]),o.push(r[s+0],r[s+1])}addUVLine(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])}addFace(t,e,s,r,o,n,i,a,l){const c=this.vertices.length;let h=this.parseVertexIndex(t,c),u=this.parseVertexIndex(e,c),d=this.parseVertexIndex(s,c);if(this.addVertex(h,u,d),void 0!==r&&""!==r){const t=this.uvs.length;h=this.parseUVIndex(r,t),u=this.parseUVIndex(o,t),d=this.parseUVIndex(n,t),this.addUV(h,u,d)}if(void 0!==i&&""!==i){const t=this.normals.length;h=this.parseNormalIndex(i,t),u=i===a?h:this.parseNormalIndex(a,t),d=i===l?h:this.parseNormalIndex(l,t),this.addNormal(h,u,d)}this.colors.length>0&&this.addColor(h,u,d)}addPointGeometry(t){this.object.geometry.type="Points";const e=this.vertices.length;for(const s of t)this.addVertexPoint(this.parseVertexIndex(s,e))}addLineGeometry(t,e){this.object.geometry.type="Line";const s=this.vertices.length,r=this.uvs.length;for(const e of t)this.addVertexLine(this.parseVertexIndex(e,s));for(const t of e)this.addUVLine(this.parseUVIndex(t,r))}}function h(t,e){const{meshes:s}=(t=>{const e=new c;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const s=t.split("\n");let r="",a="",l=0,h=[];const u="function"==typeof"".trimLeft;for(let t=0,c=s.length;t<c;t++)if(r=s[t],r=u?r.trimLeft():r.trim(),l=r.length,0!==l&&(a=r.charAt(0),"#"!==a))if("v"===a){const t=r.split(/\s+/);switch(t[0]){case"v":e.vertices.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),8===t.length&&e.colors.push(parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6]));break;case"vn":e.normals.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":e.uvs.push(parseFloat(t[1]),parseFloat(t[2]))}}else if("f"===a){const t=r.substr(1).trim().split(/\s+/),s=[];for(let e=0,r=t.length;e<r;e++){const r=t[e];if(r.length>0){const t=r.split("/");s.push(t)}}const o=s[0];for(let t=1,r=s.length-1;t<r;t++){const r=s[t],n=s[t+1];e.addFace(o[0],r[0],n[0],o[1],r[1],n[1],o[2],r[2],n[2])}}else if("l"===a){const t=r.substring(1).trim().split(" ");let s;const o=[];if(-1===r.indexOf("/"))s=t;else{s=[];for(let e=0,r=t.length;e<r;e++){const r=t[e].split("/");""!==r[0]&&s.push(r[0]),""!==r[1]&&o.push(r[1])}}e.addLineGeometry(s,o)}else if("p"===a){const t=r.substr(1).trim().split(" ");e.addPointGeometry(t)}else if(null!==(h=o.exec(r))){const t=(" "+h[0].substr(1).trim()).substr(1);e.startObject(t)}else if(i.test(r))e.object.startMaterial(r.substring(7).trim(),e.materialLibraries);else if(n.test(r))e.materialLibraries.push(r.substring(7).trim());else{if("s"!==a){if("\0"===r)continue;throw new Error(`Unexpected line: "${r}"`)}{if(h=r.split(" "),h.length>1){const t=h[1].trim().toLowerCase();e.object.smooth="0"!==t&&"off"!==t}else e.object.smooth=!0;const t=e.object.currentMaterial();t&&(t.smooth=e.object.smooth)}}e.finalize();const d=[],p=[];for(const t of e.objects){const{geometry:e}=t;if(0===e.vertices.length)continue;const s={header:{vertexCount:e.vertices.length/3},attributes:{}};switch(e.type){case"Points":s.mode=0;break;case"Line":s.mode=1;break;default:s.mode=4}s.attributes.POSITION={value:new Float32Array(e.vertices),size:3},e.normals.length>0&&(s.attributes.NORMAL={value:new Float32Array(e.normals),size:3}),e.colors.length>0&&(s.attributes.COLOR_0={value:new Float32Array(e.colors),size:3}),e.uvs.length>0&&(s.attributes.TEXCOORD_0={value:new Float32Array(e.uvs),size:2}),s.materials=[];for(const e of t.materials){const t={name:e.name,flatShading:!e.smooth};s.materials.push(t),p.push(t)}s.name=t.name,d.push(s)}return{meshes:d,materials:p}})(t),a=s.reduce((t,e)=>t+e.header.vertexCount,0),l=function(t,e){const s=new Float32Array(3*e);let r,o,n,i=0;for(const a of t){const{POSITION:t,NORMAL:l,COLOR_0:c,TEXCOORD_0:h}=a.attributes;s.set(t.value,3*i),l&&(r=r||new Float32Array(3*e),r.set(l.value,3*i)),c&&(o=o||new Float32Array(3*e),o.set(c.value,3*i)),h&&(n=n||new Float32Array(2*e),n.set(h.value,2*i)),i+=t.value.length/3}const a={};a.POSITION={value:s,size:3},r&&(a.NORMAL={value:r,size:3});o&&(a.COLOR_0={value:o,size:3});n&&(a.TEXCOORD_0={value:n,size:2});return a}(s,a);return{loaderData:{header:{}},header:{vertexCount:a,boundingBox:r(l)},mode:4,attributes:l}}const u={id:"obj",name:"OBJ",version:"2.2.8",extensions:["obj"],mimeTypes:["text/plain"],testText:function(t){return"v"===t[0]},options:{obj:{workerUrl:"https://unpkg.com/@loaders.gl/obj@2.2.8/dist/obj-loader.worker.js"}}},d={...u,parse:async(t,e)=>h((new TextDecoder).decode(t)),parseTextSync:h}}])}));